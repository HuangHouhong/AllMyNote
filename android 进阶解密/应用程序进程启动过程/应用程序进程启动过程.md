

[TOC]

# 简介

AMS 在启动应用程序的时候，会首先检查进程是否存在，如果不存在，就会创建该应用程序的进程。

Zygote 的 java 框架层中会创建一个 Server 端的 socket，这个 Socket 用来等待 AMS 请求 Zygote 来创建新的应用程序进程。

Zygote 通过 fock 自身来创建应用程序进程，这样应用程序进程就会获得 Zygote 进程在启动时创建的虚拟机实例

# 应用程序启动过程介绍

## 1.  AMS 发送启动应用程序请求

首先 AMS 会调用 startProcessLocked 方法，向 Zygote 发送创建进程的请求。startProcessLocked 方法有多个重载方法，但是最终都会调用到下面的这个重载方法：

```java
    private final void startProcessLocked(ProcessRecord app, String hostingType,
                                          String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
        ......
        try {
            ......
            // 获取要创建进程的用户id
            int uid = app.uid;
            int[] gids = null;
            int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
            if (!app.isolated) {
                ......

                // 对用户组id进行创建和赋值
                if (ArrayUtils.isEmpty(permGids)) {
                    gids = new int[3];
                } else {
                    gids = new int[permGids.length + 3];
                    System.arraycopy(permGids, 0, gids, 3, permGids.length);
                }
                gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
                gids[1] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid));
                gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid));
            }
            ......
            app.gids = gids;
            app.requiredAbi = requiredAbi;
            app.instructionSet = instructionSet;

            // the per-user SELinux context must be set
            if (TextUtils.isEmpty(app.info.seInfoUser)) {
                Slog.wtf(TAG, "SELinux tag not defined",
                        new IllegalStateException("SELinux tag not defined for "
                                + app.info.packageName + " (uid " + app.uid + ")"));
            }
            final String seInfo = app.info.seInfo
                    + (TextUtils.isEmpty(app.info.seInfoUser) ? "" : app.info.seInfoUser);
            // 以下内容就是启动进程。如果成功，就返回一个pid，失败就 RuntimeException
            boolean isActivityProcess = (entryPoint == null);
            // android.app.ActivityThread 就是需要启动的应用进程主线程的类名
            if (entryPoint == null) entryPoint = "android.app.ActivityThread";
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " +
                    app.processName);
            checkTime(startTime, "startProcess: asking zygote to start proc");
            ProcessStartResult startResult;
            if (hostingType.equals("webview_service")) {
                startResult = startWebView(entryPoint,
                        app.processName, uid, uid, gids, debugFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, null, entryPointArgs);
            } else {
                startResult = Process.start(entryPoint,
                        app.processName, uid, uid, gids, debugFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, invokeWith, entryPointArgs);
            }
            ......
        } catch (RuntimeException e) {
            Slog.e(TAG, "Failure starting process " + app.processName, e);
            forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false,
                    false, true, false, false, UserHandle.getUserId(app.userId), "start failure");
        }
    }
```

从上面代码可以看到，被启动的应用进程主线程名称是： android.app.ActivityThread 。

继续看 Process#start 方法，该方法内部其实就是调用了 ZygoteProcess#start 方法，然后再调用 startViaZygote 方法：

```java
private Process.ProcessStartResult startViaZygote(......)
        throws ZygoteStartFailedEx {
    // 将待启动进程的参数保存在该List中。
    ArrayList<String> argsForZygote = new ArrayList<String>();
    argsForZygote.add("--runtime-args");
    argsForZygote.add("--setuid=" + uid);
    argsForZygote.add("--setgid=" + gid);
    ......


    synchronized(mLock) {
        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);
    }
}
```

该方法比较简单，首先对传入进来的参数进行封装，然后在调用 zygoteSendArgsAndGetResult 方法。

第一个参数是 openZygoteSocketIfNeeded 方法返回值 ZygoteState 。在该方法中，去尝试开启一个 socket 连接，如果已有，就不再开启，如果没有，就尝试开启。ZygoteState 是 ZygoteProcess 的内部类，他是对 socket 的一个包装。

第二个参数，是保证进程能够启动的参数。

zygoteSendArgsAndGetResult 方法实现如下：

```java
/**
 * 向zygote进程发送参数列表，zygote进程会启动一个新的子进程并返回子进程的pid
 * 注意：当前使用空格替换参数列表中的换行符
 */
@GuardedBy("mLock")
private static Process.ProcessStartResult zygoteSendArgsAndGetResult(
        ZygoteState zygoteState, ArrayList<String> args)
        throws ZygoteStartFailedEx {
    try {
        // 参数格式不正确，里面有换行符，直接跑出异常
        int sz = args.size();
        for (int i = 0; i < sz; i++) {
            if (args.get(i).indexOf('\n') >= 0) {
                throw new ZygoteStartFailedEx("embedded newlines not allowed");
            }
        }
        final BufferedWriter writer = zygoteState.writer;
        final DataInputStream inputStream = zygoteState.inputStream;

        writer.write(Integer.toString(args.size()));
        writer.newLine();

        for (int i = 0; i < sz; i++) {
            String arg = args.get(i);
            writer.write(arg);
            writer.newLine();
        }

        writer.flush();

        Process.ProcessStartResult result = new Process.ProcessStartResult();

        result.pid = inputStream.readInt();
        result.usingWrapper = inputStream.readBoolean();

        if (result.pid < 0) {
            throw new ZygoteStartFailedEx("fork() failed");
        }
        return result;
    } catch (IOException ex) {
        zygoteState.close();
        throw new ZygoteStartFailedEx(ex);
    }
}
```

zygoteSendArgsAndGetResult 方法其实就是简单的将参数通过 socket 发送给 Zygote 。

## 2.  Zygote接受请求并创建创建应用程序进程

Zygote 进程接收到 socket 发送过来的参数后，就会创建子进程。zygoteSendArgsAndGetResult 方法的第一个参数，其实就是创建的 socket 连接，该 socketName为 zygote，这个 socket 是在 ZygoteInit#main 方法中注册的。

```java
    public static void main(String argv[]) {
        ZygoteServer zygoteServer = new ZygoteServer();
        ......
        final Runnable caller;
        try {
            ......
            // 创建一个server端socket，socketName为zygote
            zygoteServer.registerServerSocket(socketName);
            ......
            // 启动 systemserver 进程
            if (startSystemServer) {
                Runnable r = forkSystemServer(abiList, socketName, zygoteServer);

                // zygote 进程中时，r 为 null。 其他进程中，r 不为 null
                if (r != null) {
                    // 这里 r 就是MethodAndArgsCaller 对象
                    r.run();
                    return;
                }
            }
            // 开启循环，等待AMS请求。他会在子进程fock完成之前返回
            caller = zygoteServer.runSelectLoop(abiList);
        } catch (Throwable ex) {
            Log.e(TAG, "System zygote died with exception", ex);
            throw ex;
        } finally {
            zygoteServer.closeServerSocket();
        }
        if (caller != null) {
            caller.run();
        }
    }
```

如上所示，ZygoteInit#main 方法总共进行了3步：

1. 创建名称为 zygote 的 server 端 socket
2.  启动 SystemServer 进程，这样系统服务就可以有 SystemServer 启动起来。 启动完成后就直接返回了。
3. 如果本次不是启动 SystemServer进程，调用 ZygoteServer#runSelectLoop 方法，来等待 AMS 请求创建新的应用进程

ZygoteServer#runSelectLoop 返回一个 Runnable 对象，然后在 ZygoteInit#main 中执行 run 方法。

```java
/**
 * zygote 进程开启循环。接受新的socket 链接，并且从连接中读取命令
 */
Runnable runSelectLoop(String abiList) {
    ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();
    ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();

    fds.add(mServerSocket.getFileDescriptor());
    peers.add(null);

    while (true) {
        ......
                try {
                    ZygoteConnection connection = peers.get(i);
                    // 调用了 ZygoteConnection 的方法获取 Runnable 对象
                    final Runnable command = connection.processOneCommand(this);

                    if (mIsForkChild) {
                        // 子进程中，command一定不可以为null
                        if (command == null) {
                            throw new IllegalStateException("command == null");
                        }
                        return command;
                    } else {
                        // 在 server 进程中。
                        if (command != null) {
                            throw new IllegalStateException("command != null");
                        }
                        ......
                    }
                } catch (Exception e) {
                    ......
                }
        ......
    }
}
```

其实就是开启一个循环，然后调用 ZygoteConnection#processOneCommand 产生一个 Runnable 对象并返回：

```java
/**
 *
 * 从命令套接字读取一个启动命令。
 * 如果成功，则派生一个子进程，并在子进程中返回一个 Runnable 对象，该 Runnable 调用子进程的主方法。
 * 如果失败，则在父进程（Zygote进程）中返回 null
 */
Runnable processOneCommand(ZygoteServer zygoteServer) {
    String args[];
    Arguments parsedArgs = null;
    FileDescriptor[] descriptors;

    try {
        // 获取应用进程的启动参数
        args = readArgumentList();
        descriptors = mSocket.getAncillaryFileDescriptors();
    } catch (IOException ex) {
        throw new IllegalStateException("IOException on command socket", ex);
    }
    ......
    // 将启动参数封装一下
    parsedArgs = new Arguments(args);
    ......
    // fock 一个子进程.forkAndSpecialize调用了native方法创建子进程。
    // 如果返回为0 ，说明子进程创建成功并切换到子进程了
    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
            parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
            parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.instructionSet,
            parsedArgs.appDataDir);

    try {
        if (pid == 0) {
            // 当前代码运行在子进程，给 ZygoteServer 设置一下参数
            zygoteServer.setForkChild();

            // 关闭socket
            zygoteServer.closeServerSocket();
            IoUtils.closeQuietly(serverPipeFd);
            serverPipeFd = null;

            // 处理应用程序进程
            return handleChildProc(parsedArgs, descriptors, childPipeFd);
        } else {
            // pid < 0  说明当前子进程创建失败，还是在父进程。需要清理一下父进程fock时的信息
            IoUtils.closeQuietly(childPipeFd);
            childPipeFd = null;
            handleParentProc(pid, descriptors, serverPipeFd);
            return null;
        }
    } finally {
        IoUtils.closeQuietly(childPipeFd);
        IoUtils.closeQuietly(serverPipeFd);
    }
}
```

失败了，就直接返回null了，如果成功 fock 了一个进程，就会切换到 fock 的这个子进程中，然后调用 handleChildProc 方法：

```java
/**
 * 如果成功，处理子进程设置，根据需要关闭socket，根据需要创建 stdio。
 * 如果失败，就抛出 MethodAndArgsCaller
 */
private Runnable handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors,
                                 FileDescriptor pipeFd) {
    // 代码走到这里，native方法里面已经关了两个zygote进程的socket连接，并替换为了/dev/null.
    // 但是 LocalSocket 对象仍然需要关闭一下
    closeSocket();
    ......
    if (parsedArgs.invokeWith != null) {
        WrapperInit.execApplication(parsedArgs.invokeWith,
                parsedArgs.niceName, parsedArgs.targetSdkVersion,
                VMRuntime.getCurrentInstructionSet(),
                pipeFd, parsedArgs.remainingArgs);

        // Should not get here.
        throw new IllegalStateException("WrapperInit.execApplication unexpectedly returned");
    } else {
        return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,
                null /* classLoader */);
    }
}
```

可以看到，fock 完子进程后，又调用了 ZygoteInit.zygoteInit 方法：

```java
public static final Runnable zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) {
    if (RuntimeInit.DEBUG) {
        Slog.d(RuntimeInit.TAG, "RuntimeInit: Starting application from zygote");
    }

    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ZygoteInit");
    RuntimeInit.redirectLogStreams();

    RuntimeInit.commonInit();
    // 调用本地方法，创建binder线程池。
    ZygoteInit.nativeZygoteInit();
    return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);
}
```

这个方法就两步

1. 创建 binder 线程池
2. 调用 RuntimeInit.applicationInit 方法

RuntimeInit.applicationInit  ，内部其实就是通过类名，反射创建一个对象，然后找到 main 方法，封装成 MethodAndArgsCaller 对象。，然后在  ZygoteInit#main  方法中调用 MethodAndArgsCaller#run 方法反射调用 main 方法。类的名称是 AMS#startProcessLocked 直接指定的 android.app.ActivityThread ，通过 socket 层层传递，一直传递到这里。

 ActivityThread#main 方法如下：

```java
public static void main(String[] args) {
    .....
    // 创建主线程 Looper
    Looper.prepareMainLooper();

    ActivityThread thread = new ActivityThread();
    thread.attach(false);
    // 创建主线程 Handler 类
    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }
    ......
    // 开启 Looper 循环
    Looper.loop();
    throw new RuntimeException("Main thread loop unexpectedly exited");
}
```

ActvityThread 用于管理当前应用程序进程的主线程。至此，整个应用进程就启动完毕了。

## 如何创建线程池？

fock 完成子进程后，会调用到 ZygoteInit#zygoteInit 方法，在启动 ActvityThread#main 方法前，会调用  ZygoteInit.nativeZygoteInit()  本地方法去创建。

全局搜索 nativeZygoteInit ，会发现在AndroidRuntime.cpp 文件中注册：

```c++
int register_com_android_internal_os_ZygoteInit_nativeZygoteInit(JNIEnv* env)
{
    const JNINativeMethod methods[] = {
        { "nativeZygoteInit", "()V",
            (void*) com_android_internal_os_ZygoteInit_nativeZygoteInit },
    };
    return jniRegisterNativeMethods(env, "com/android/internal/os/ZygoteInit",
        methods, NELEM(methods));
}

static void com_android_internal_os_ZygoteInit_nativeZygoteInit(JNIEnv* env, jobject clazz)
{
    gCurRuntime->onZygoteInit();
}
```

其中 gCurRuntime 就是 AndroidRuntime 对象。但是该对象中没有 onZygoteInit 方法。查阅资料得知， AppRuntime 是 AndroidRuntime 继承类，这里的 gCurRuntime 就是 AppRuntime。 找到 app_main.cpp 文件，AppRuntime 是里面的内部类，onZygoteInit 方法如下：

```c++
virtual void onZygoteInit()
{
    sp<ProcessState> proc = ProcessState::self();
    ALOGV("App process: starting thread pool.\n");
    proc->startThreadPool();
}
```

继续看 ProcessState.cpp 类：

```c++
void ProcessState::startThreadPool()
{
    AutoMutex _l(mLock);
    // mThreadPoolStarted 为false，表示没有启动过线程池
    if (!mThreadPoolStarted) {
        mThreadPoolStarted = true;
        if (mSpawnThreadOnStart) {
            spawnPooledThread(true);
        }
    }
}

void ProcessState::spawnPooledThread(bool isMain)
{
    if (mThreadPoolStarted) {
        String8 name = makeBinderThreadName();
        ALOGV("Spawning new pooled thread, name=%s\n", name.string());
        sp<Thread> t = new PoolThread(isMain);
        t->run(name.string());
    }
}
```

可以看到，最终在 spawnPooledThread 方法中创建了 PoolThread 类，并调用了 run 方法。

```c++
class PoolThread : public Thread
{
public:
    explicit PoolThread(bool isMain)
        : mIsMain(isMain)
    {
    }

protected:
    virtual bool threadLoop()
    {
        IPCThreadState::self()->joinThreadPool(mIsMain);
        return false;
    }

    const bool mIsMain;
};
```

IPCThreadState#joinThreadPool 方法，就是把当前线程注册到 Binder 驱动程序里面，这样我们创建的线程就加入到了binder 线程池中，新创建的应用程序进程就支持 Binder 通信了。