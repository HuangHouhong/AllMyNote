[TOC]

# 简介

安卓系统中的桌面启动器，安卓系统的桌面UI统称为Launcher

# Launcher 启动

在 SystemServer 启动完成后，会调用 startOtherServices 方法去启动其他服务，其中就包括了 ActivityManagerService，启动完成 AMS后， 会继续调用 AMS#systemReady 方法

```java
public void systemReady(final Runnable goingCallback, TimingsTraceLog traceLog) {
    ......
    synchronized (this) {
        ......
        startHomeActivityLocked(currentUserId, "systemReady");
        ......
    }
}
```

可以看到直接调用了自身的 startHomeActivityLocked 方法

```java
boolean startHomeActivityLocked(int userId, String reason) {
    ......
    // 获取第一个Activity的Intent。非工厂模式时，第一个Activity就是Launcher
    Intent intent = getHomeIntent();
    ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);
    if (aInfo != null) {
        intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));
        // Don't do this if the home app is currently being instrumented.
        aInfo = new ActivityInfo(aInfo);
        aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);
        ProcessRecord app = getProcessRecordLocked(aInfo.processName,
                aInfo.applicationInfo.uid, true);
        if (app == null || app.instr == null) {
            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
            final int resolvedUserId = UserHandle.getUserId(aInfo.applicationInfo.uid);
            // For ANR debugging to verify if the user activity is the one that actually
            // launched.
            final String myReason = reason + ":" + userId + ":" + resolvedUserId;
            
            // 调用 ActivityStart 启动 Launcher
            mActivityStarter.startHomeActivityLocked(intent, aInfo, myReason);
        }
    } else {
        Slog.wtf(TAG, "No home screen found for " + intent, new Throwable());
    }

    return true;
}

Intent getHomeIntent() {
        // mTopAction是用来描述第一个启动的Activity的Action。在非工厂模式时，该值为 Intent.ACTION_MAIN
        Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);
        intent.setComponent(mTopComponent);
        intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);
        // 非工厂模式，添加 category
        if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            intent.addCategory(Intent.CATEGORY_HOME);
        }
        return intent;
}
```

到 packages/apps/Launcher3/AndroidManifest.xml 看到，Launcher 的属性如下定义：

```xml
<activity
    android:name="com.android.launcher3.Launcher"
    android:launchMode="singleTask"
    android:clearTaskOnLaunch="true"
    android:stateNotNeeded="true"
    android:windowSoftInputMode="adjustPan"
    android:screenOrientation="nosensor"
    android:configChanges="keyboard|keyboardHidden|navigation"
    android:resizeableActivity="true"
    android:resumeWhilePausing="true"
    android:taskAffinity=""
    android:enabled="true">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.HOME" />
        <category android:name="android.intent.category.DEFAULT" />
        <category android:name="android.intent.category.MONKEY"/>
        <category android:name="android.intent.category.LAUNCHER_APP" />
    </intent-filter>
</activity>
```

可以看到，上面 getHomeIntent 在非工厂模式，启动的就是 Launcher 这个 Activity。

# Launcher 图标展示过程

入口就是 Launcher#onCreate 方法：

```java
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ......
        // 获取 LauncherAppState 实例
        LauncherAppState app = LauncherAppState.getInstance(this);
        ......

        // 给 LauncherAppState 传入 Launcher 对象 ，获取 LauncherModel 对象
        mModel = app.setLauncher(this);
        ......

        // 调用 LauncherModel 的 startLoader 方法
        if (!mModel.startLoader(currentScreen)) {
            mDragLayer.setAlpha(0);
        } else {
            mWorkspace.setCurrentPage(currentScreen);
            setWorkspaceLoading(true);
        }
        ......
    }
```

如上所示，主要就是三个步骤。

第三步调用了LauncherModel#startLoader 方法

```java
public boolean startLoader(int synchronousBindPage) {
    // Enable queue before starting loader. It will get disabled in Launcher#finishBindingItems
    InstallShortcutReceiver.enableInstallQueue(InstallShortcutReceiver.FLAG_LOADER_RUNNING);
    synchronized (mLock) {
        // mCallbacks 就是 Launcher 弱引用。如果不存在，就不需要加载了
        if (mCallbacks != null && mCallbacks.get() != null) {
            final Callbacks oldCallbacks = mCallbacks.get();
            // Clear any pending bind-runnables from the synchronized load process.
            mUiExecutor.execute(new Runnable() {
                        public void run() {
                            oldCallbacks.clearPendingBinds();
                        }
                    });

            // 如果 LoaderTask 正在运行中，停止运行正在进行的任务
            stopLoader();
            LoaderResults loaderResults = new LoaderResults(mApp, sBgDataModel,
                    mBgAllAppsList, synchronousBindPage, mCallbacks);
            
            /*
             * LoaderTask#run 方法被调用，mIsLoaderTaskRunning 就赋值为true。
             * LoaderTask#close 方法被调用，mIsLoaderTaskRunning 就赋值为false
             * mModelLoaded#commit 方法被调用，mModelLoaded 就赋值为true。
             * 
             * mModelLoaded && !mIsLoaderTaskRunning 为true ，表示 LoaderTask 已经运行完并成功
             * 
             */
            if (mModelLoaded && !mIsLoaderTaskRunning) {
                loaderResults.bindWorkspace();
                loaderResults.bindAllApps();
                loaderResults.bindDeepShortcuts();
                loaderResults.bindWidgets();
                return true;
            } else {
                // 主线程启动 LoaderTask 任务
                startLoaderForResults(loaderResults);
            }
        }
    }
    return false;
}

public void startLoaderForResults(LoaderResults results) {
        synchronized (mLock) {
            stopLoader();
            mLoaderTask = new LoaderTask(mApp, mBgAllAppsList, sBgDataModel, results);
            runOnWorkerThread(mLoaderTask);
        }
}
```

如上所示，相关的变量就是 LoaderResults， LoaderTask。并且两者的参数高度相似。比如 mBgAllAppsList 这个参数，两者使用的是同一个 AllAppsList 对象，该对象仅仅只能在主线程工作。

LoaderTask 是一个 Runnable 对象，run 方法大概如下：

```java
public void run() {
        ......
        // 加载工作区
        loadWorkspace();
        // 判断是否需要停止工作，如果需要停止，直接跑出异常
        verifyNotStopped();
        // 绑定工作区信息
        mResults.bindWorkspace();
        // 线程停止1s，让工作区加载完成
        waitForIdle();
        verifyNotStopped();
        // 加载已经安装的应用程序信息
        loadAllApps();
        verifyNotStopped();
        // 绑定已经安装的应用程序信息
        mResults.bindAllApps();
        ......
}
```

省略掉一些代码后，如上。其中 mResults 就是  LoaderResults， 是在 LauncherModel 中初始化完成并传入到这里面的。

loadAllApps 方法，其实就是通过 LauncherAppsCompat 获取所有的 Activity，然后封装成 AppInfo 放入到 mBgAllAppsList 中。

接下来看看  mResults.bindAllApps()， 即 LoaderResults#bindAllApps 方法：

```java
public void bindAllApps() {
    // mBgAllAppsList 与 LoaderTask 中 mBgAllAppsList 实际上是同一个对象，LoaderTask#loadAllApps 会填充改列表
    final ArrayList<AppInfo> list = (ArrayList<AppInfo>) mBgAllAppsList.data.clone();

    Runnable r = new Runnable() {
        public void run() {
            Callbacks callbacks = mCallbacks.get();
            if (callbacks != null) {
                // callbacks 实际上就是 Launcher 对象
                callbacks.bindAllApplications(list);
            }
        }
    };
    mUiExecutor.execute(r);
}
```

其实就是流转一下，交给 Launcher#bindAllApplications 方法          

```java
/**
 * 添加待展示到屏幕上的icon
 *
 * LauncherModel.Callbacks 接口的方法的继承
 * 
 * @param apps 需要展示的app列表
 * 
 */
public void bindAllApplications(final ArrayList<AppInfo> apps) {
    Runnable r = new RunnableWithId(RUNNABLE_ID_BIND_APPS) {
        public void run() {
            bindAllApplications(apps);
        }
    };
    if (waitUntilResume(r)) {
        return;
    }

    if (mAppsView != null) {
        Executor pendingExecutor = getPendingExecutor();
        if (pendingExecutor != null && mState != State.APPS) {
            // 在设置所有应用列表之前，请等待淡入动画完成。
            pendingExecutor.execute(r);
            return;
        }

        // 把需要展示的apps 设置到 AllAppsContainerView
        mAppsView.setApps(apps);
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.bindAllApplications(apps);
    }
}
```

可以看到，其实就是把待展示的app 列表传递到 AllAppsContainerView 这个View中。在该类的 onFinishInflate 方法中可以看到，他内部含有一个 RecycleView 把所有的 App 图标展示出来