[TOC]

# PC 是启动流程

电脑启动该流程基本分为两个阶段

- 引导阶段
- 加载内核阶段

## 引导阶段

引导阶段分为三个部分：

- 读取 BIOS

  BIOS ，即 Basic Input/Output System（基本输入输出系统），一般是主板芯片上的一个程序，计算机通电后，第一件事就是读取它。

  BIOS 程序首先检查计算机硬件能否满足运行的基本条件，这叫做"硬件自检"（Power-On Self-Test），缩写为 POST。 如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。 如果没有问题，屏幕就会显示出 CPU，内存，硬盘等信息。

  硬件自检完成后，BIOS 把控制权转交给下一阶段的启动程序

- 启动程序

  第一存储设备被激活后，计算机读取该设备的第一个扇区，也就是读取最前面的 512 个字节。

  这512 个字节可以判断当前这个设备是否可以用于启动。如果不可以，就交给“启动顺序”的下一个设备

- 主引导记录

  第一存储设备最前面的512个字节叫做 主引导记录（Master boot record，缩写为 MBR）。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统

## 加载内核阶段

引导阶段选择完操作系统后，控制权转交给操作系统，操作系统的内核首先被载入内存。

以 Linux 系统为例，先载入 /boot 目录下面的 kernel。  内核加载成功后，第一个运行的程序是 /sbin/init。 它根据配置文件（Debian 系统是 /etc/initab ）产生 init 进程。 这是 Linux 启动后的第一个进程，pid 进程编号为 1，其他进程都是它的后代。

至此，全部的启动过程就完成了

# Android启动流程

Android 系统基于Linux系统，但是 Android 属于嵌入式设备，并不像 pc 机一样有 
BIOS 程序，取而代之的是 BootLoader ，即系统加载器。可以理解为BootLoader 就是操作系统内核运行之前运行的一段小程序。

Android 运行环境没有硬盘，而是ROM，它类似于硬盘存放操作系统，用户程序等。

ROM 跟硬盘一样也会划分为不同的区域，用于放置不同的程序。Android 系统分区如下：

| 功能      | 系统分区                                                     |
| --------- | ------------------------------------------------------------ |
| /boot     | 存放引导程序，包括内核和内存操作程序                         |
| /system   | 相当于电脑c盘，存放Android系统及系统应用                     |
| /recovery | 恢复分区，可以进入该分区进行系统恢复                         |
| /data     | 用户数据区，包含了用户的数据：联系人、短信、设置、用户安装的程序 |
| /cache    | 安卓系统缓存区，保存系统最常访问的数据和应用程序             |
| /misc     | 包含一些杂项内容，如系统设置和系统功能启用禁用设置           |
| /sdcard   | 用户自己的存储区，可以存放照片，音乐，视频等文件             |

Android 设备按下电源后，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序到RAM，然后执行下面步骤：

- BootLoader

  Bootloader 程序分两个阶段执行。第一个阶段，检测外部的RAM以及加载对第二阶段有用的程序；第二阶段，设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，Bootloader 可以根据配置参数或者输入数据设置内核。

- kernel

  kernel开始启动时，设置缓存、被保护存储器、计划列表，加载驱动。

  当kernel完成系统设置，它首先在系统文件中寻找“init”文件，然后启动root进程或者系统的第一个进程。

- init 进程

  init用户空间的第一个进程。init 进程有两个责任:

  1. 挂载目录，比如/sys、/dev、/proc
  2. 运行init.rc脚本。

  init 启动 init.rc 脚本后，就会启动zygote进程，然后拉起系统服务，进入launcher进程，整个android 系统就启动完成了。

# init进程入口

init 进程是用户空间的第一个进程。

用户按下开机键，引导芯片加载 BootLoader ，开始拉起Linux 内核，linux 内核启动完毕后，他就会在系统中寻找到 /system/core/init/init.cpp 文件，然后执行main 方法。main 方法就是整个系统启动的入口，如下所示：

```c++
int main(int argc, char** argv) {
    
    // 第一部分。根据传入匹配，运行不同的函数
    if (!strcmp(basename(argv[0]), "ueventd")) {
        return ueventd_main(argc, argv);
    }
    ......

    // 第二部分。设置环境变量
    add_environment("PATH", _PATH_DEFPATH);

    // 第三部分。如果是第一次启动，就创建文件目录并挂载对应的设备
    bool is_first_stage = (getenv("INIT_SECOND_STAGE") == nullptr);
    if (is_first_stage) {
        ......
    }
    ......

    // 第四部分。运行属性服务
    property_init();
    ......

    // 第五部分。解析init.rc文件，启动相应的进程
    epoll_fd = epoll_create1(EPOLL_CLOEXEC);
    if (epoll_fd == -1) {
        PLOG(ERROR) << "epoll_create1 failed";
        exit(1);
    }

    //用于设置子进程信号处理函数（如Zygote），如果子进程异常退出，init进程会调用该函数中设定的信号处理函数来处理
    signal_handler_init();

    ......
    
    //启动属性服务
    start_property_service();
    
    ......

    std::string bootscript = GetProperty("ro.boot.init_rc", "");
    if (bootscript.empty()) {
        // 解析init.rc 文件
        parser.ParseConfig("/init.rc");
        parser.set_is_system_etc_init_loaded(
                parser.ParseConfig("/system/etc/init"));
        parser.set_is_vendor_etc_init_loaded(
                parser.ParseConfig("/vendor/etc/init"));
        parser.set_is_odm_etc_init_loaded(parser.ParseConfig("/odm/etc/init"));
    } else {
        parser.ParseConfig(bootscript);
        parser.set_is_system_etc_init_loaded(true);
        parser.set_is_vendor_etc_init_loaded(true);
        parser.set_is_odm_etc_init_loaded(true);
    }

    ......

    return 0;
}
```

如上所示，main 代码核心分为5个步骤，主要的工作点是一下几点：

- 创建并挂载启动所需要的目录
- 初始化和启动属性服务（即调用  property_init 方法对属性进行初始化，调用 start_property_service 方法启动属性服务）
- 解析 init.rc 文件并启动Zygote进程

# init.rc

该文件地址为： /system/core/rootdir/init.rc

init.rc 文件是一个配置文件，他是由 Android Init Language （AIL）语言编写。

```
import /init.environ.rc
import /init.usb.rc
import /init.${ro.hardware}.rc
import /vendor/etc/init/hw/init.${ro.hardware}.rc
import /init.usb.configfs.rc
import /init.${ro.zygote}.rc
......
```

在init.rc中，有五种类型语句，分别为 Action，Command，Service，Option，Import。

该文件顶部使用 Import 类型语句引入了一些其他的配置文件，其中 init.${ro.zygote}.rc 是根据设备处理器来选择执行文件的。比如在64为处理器，使用的就是 init.zygote64.rc 文件，在这些init.${ro.zygote}.rc文件中定义了启动zygote 进程的服务。

