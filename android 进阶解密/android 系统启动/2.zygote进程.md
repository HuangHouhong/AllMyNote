

[TOC]

# zygote 进程

zygote 进程是 java 进程的鼻祖，由用户空间鼻祖 init 进程 fork出来的。

zygote 进程在android系统中有着及其中要的位置，所有应用进程都是zygote的子进程.

init 进程启动过程中，会解析 init.rc 文件，在该文件中，会使用import 引入init.${ro.zygote}.rc 文件，zygote 文件总共有4个，我们以64为处理器为例子。

# 定义服务与触发服务

init.zygote64.rc 定义了zygote 这个服务

```
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server
    class main
    priority -20
    user root
    group root readproc
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart audioserver
    onrestart restart cameraserver
    onrestart restart media
    onrestart restart netd
    onrestart restart wificond
    writepid /dev/cpuset/foreground/tasks
```

该文件其实就是定义一个service ，service 语法如下：

```
// name : 服务名称
// pathname : 此服务所在的路径
// argument : 启动服务所带的参数
service <name><pathname> [ <argument> ]*
    <option>
    <option>
```

可以看到，其实就是定义一个名称为 zygote 的service，路径是 /system/bin/app_process64

接着去init.rc 文件中，可以找到zygote 的启动事件

```
on late-init
	......
    # Now we can start zygote for devices with file based encryption
    trigger zygote-start
	.....
	
	
on zygote-start && property:ro.crypto.state=unencrypted
    # A/B update verifier that marks a successful boot.
    exec_start update_verifier_nonencrypted
    start netd
    start zygote
    start zygote_secondary

on zygote-start && property:ro.crypto.state=unsupported
    # A/B update verifier that marks a successful boot.
    exec_start update_verifier_nonencrypted
    start netd
    start zygote
    start zygote_secondary

on zygote-start && property:ro.crypto.state=encrypted && property:ro.crypto.type=file
    # A/B update verifier that marks a successful boot.
    exec_start update_verifier_nonencrypted
    start netd
    start zygote
    start zygote_secondary
	
```

如上所示，上面是rc 文件的Action语句，语法定义：

```
on  <trigger>       //触发条件，使用trigger 命令即可触发这个触发器
    <command>      //执行命令
    <command1>     //可以执行多个命令
```

可以看到，late-init 事件触发后，就会继续执行 zygote-start 事件，zygote-start事件执行后，根据满足不同的条件，执行三种不同的命令组，但是不管是哪个，都会 start zygote。 

start 是rc中的commands类型语句，其规则是：

```
start <service>
```

所以init.zygote64.rc 中定义的 zygote service 就被启动了。而 late-init 触发器是在 init.cpp main方法中执行的：

```cpp
// main 方法加载init.rc 文件后，继续执行下面代码
std::string bootmode = GetProperty("ro.bootmode", "");
if (bootmode == "charger") {
    am.QueueEventTrigger("charger");
} else {
    am.QueueEventTrigger("late-init");
}
```

所以，总结下来就是：

1. init.cpp # main 方法，触发 late-init 这个触发器
2. init.rc 中 late-init 触发器被触发后，触发 zygote-start 这个触发器
3. init.rc 中 zygote-start 触发起被触发后，同时满足一些其他条件，就会执行 start zygote 这个commands

# 从c++到java层

从上文中得知，zygote 原型就是 /system/bin/app_process64，该服务对应的代码路径为 frameworks/base/cmds/app_process

## app_mian.cpp

该路径下，就4个文件，启动 Android.mk 文件中定义了app_process程序的来源 app_main.cpp文件，main方法内容如下：

```c++
int main(int argc, char* const argv[])
{
    ......
    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));   
    ......
    /*
      省略解析参数的代码，参数解析出来有四种模式：
     --zygote : zygote模式
     --start-system-server : 启动一个系统服务
     --application : 以应用（独立、非zygote）模式启动
     --nice-name : 修改名字
     其中后三种，可以称为 application 模式。
     然后根据模式不同，给args赋值
    */

    if (zygote) {
        // zygote 模式
        runtime.start("com.android.internal.os.ZygoteInit", args, zygote);
    } else if (className) {
        // application 模式
        runtime.start("com.android.internal.os.RuntimeInit", args, zygote);
    } else {
        fprintf(stderr, "Error: no class name or --zygote supplied.\n");
        app_usage();
        LOG_ALWAYS_FATAL("app_process: no class name or --zygote supplied.");
    }
}
```

其实，主要就是 Runtime#start 这个方法， runtime就是 AppRuntime ，他是 AndroidRuntime 的子类，AndroidRuntime.cpp 在 fragmeworks/base/core/jni 目录下。

## AndroidRuntime.cpp

```c++
void AndroidRuntime::start(const char* className, const Vector<String8>& options, bool zygote)
{
    .......

    // 启动 java 虚拟机
    JniInvocation jni_invocation;
    jni_invocation.Init(NULL);
    JNIEnv* env;
    if (startVm(&mJavaVM, &env, zygote) != 0) {
        return;
    }
    onVmCreated(env);

    // 为java 虚拟机注册JNI 方法
    if (startReg(env) < 0) {
        ALOGE("Unable to register all android natives\n");
        return;
    }
    ......

    // 从 app_main.cpp 中 main 方法得知，这里就是 com.android.internal.os.ZygoteInit
    stringClass = env->FindClass("java/lang/String");
    assert(stringClass != NULL);
    strArray = env->NewObjectArray(options.size() + 1, stringClass, NULL);
    assert(strArray != NULL);
    classNameStr = env->NewStringUTF(className);
    .......

    //  com.android.internal.os.ZygoteInit 中点号换成斜杠
    char* slashClassName = toSlashClassName(className != NULL ? className : "");

    // 找到 ZygoteInit 类
    jclass startClass = env->FindClass(slashClassName);
    if (startClass == NULL) {
        ALOGE("JavaVM unable to locate class '%s'\n", slashClassName);
    } else {
        // 找到 ZygoteInit#main 方法
        jmethodID startMeth = env->GetStaticMethodID(startClass, "main",
            "([Ljava/lang/String;)V");
        if (startMeth == NULL) {
            ALOGE("JavaVM unable to find main() in '%s'\n", className);
        } else {
            // 通过 JNI 调用 ZygoteInit#main 方法
            env->CallStaticVoidMethod(startClass, startMeth, strArray);
        }
    }
    ......
}
```

如上所示，AndroidRuntime.cpp 做了两件事：

- 启动 jvm 虚拟机
- 找到 ZygoteInit 类，通过JNI调用他的 main 方法

从这里，Zygote 就进入到的 Java 框架层。此前没有任何代码进入Java框架层。

同时这里也看到了，进程的概念是大于虚拟机的，现有进程，才会去创建虚拟机。

# ZygoteInit.Java

该类目录在 frameworks/base/core/java/com/android/internal/os 目录下。main方法流程如下：

```java
    public static void main(String argv[]) {
        ZygoteServer zygoteServer = new ZygoteServer();
        ......

        final Runnable caller;
        try {
            ......
            // 主要就是解析调用的参数，初始化一些属性

            // 创建一个Server端的socket，socketName值为zygote
            zygoteServer.registerServerSocket(socketName);
            if (!enableLazyPreload) {
                ......
                // 预加载类和资源
                preload(bootTimingsTraceLog);
                ......
            } else {
                Zygote.resetNicePriority();
            }
            ......
            // SystemServer 进程没有启动，就创建并启动
            if (startSystemServer) {
                Runnable r = forkSystemServer(abiList, socketName, zygoteServer);
                if (r != null) {
                    r.run();
                    return;
                }
            }
            // 等待AMS请求。即监听并接受消息
            caller = zygoteServer.runSelectLoop(abiList);
        } catch (Throwable ex) {
            Log.e(TAG, "System zygote died with exception", ex);
            throw ex;
        } finally {
            zygoteServer.closeServerSocket();
        }

        if (caller != null) {
            caller.run();
        }
    }
```

main方法总结做了四件事情：

- 创建一个Server端的Socket
- 预加载类和资源
- 启动SystemServer 进程
- 等待 AMS 请求创建新的应用程序进程