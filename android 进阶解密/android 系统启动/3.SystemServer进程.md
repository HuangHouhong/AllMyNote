[TOC]

# 简介

SystemServer 进程，主要用于创建系统服务，AMS、WMS、PMS 等都是由他创建的。

# 如何启动SystemServer

从zygote进程启动流程中得知，在 ZygoteInit#main 方法中启动SystemServer进程：

```java
        // SystemServer 进程没有启动，就创建并启动
        if (startSystemServer) {
            Runnable r = forkSystemServer(abiList, socketName, zygoteServer);
            if (r != null) {
                r.run();
                return;
            }
        }
```
如上所示，通过 forkSystemServer 方法创建一个Runnable对象，然后调用该 Runnable 对象的 run 方法。

```java
private static Runnable forkSystemServer(String abiList, String socketName,
                                         ZygoteServer zygoteServer) {
    .......
    // 当前运行在 SystemServer 进程中
    if (pid == 0) {
        if (hasSecondZygote(abiList)) {
            waitForSecondaryZygote(socketName);
        }

        zygoteServer.closeServerSocket();
        return handleSystemServerProcess(parsedArgs);
    }
    return null;
}


private static Runnable handleSystemServerProcess(ZygoteConnection.Arguments parsedArgs) {
        ......
        if (parsedArgs.invokeWith != null) {
            ......
            throw new IllegalStateException("Unexpected return from WrapperInit.execApplication");
        } else {
            ClassLoader cl = null;
            // systemServerClasspath 字符串，就是 SystemServer 的路径
            if (systemServerClasspath != null) {
                // 使用 PathClassLoader 加载该类
                cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);

                Thread.currentThread().setContextClassLoader(cl);
            }
            return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);
        }
    }


public static final Runnable zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) {
        ......
        
        // 调用本地方法，启动 Binder 线程池，这样SystemServer就可以通过Binder与其他进程通信
        ZygoteInit.nativeZygoteInit();
        return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);
    }
```

如上所示，在ZygoteInit 中一顿调用，最终调用了 RuntimeInit#applicationInit 方法

```java
protected static Runnable applicationInit(int targetSdkVersion, String[] argv,
                                          ClassLoader classLoader) {
    ......
    return findStaticMain(args.startClass, args.startArgs, classLoader);
}

    private static Runnable findStaticMain(String className, String[] argv,
                                           ClassLoader classLoader) {
        
        Class<?> cl;

        try {
            cl = Class.forName(className, true, classLoader);
        } catch (ClassNotFoundException ex) {
            throw new RuntimeException(
                    "Missing class when invoking static main " + className,
                    ex);
        }

        Method m;
        try {
            m = cl.getMethod("main", new Class[] { String[].class });
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException(
                    "Missing static main on " + className, ex);
        } catch (SecurityException ex) {
            throw new RuntimeException(
                    "Problem getting static main on " + className, ex);
        }
        
        // m 其实就是 SystemServer 的 main 方法
        return new MethodAndArgsCaller(m, argv);
    }
```

MethodAndArgsCaller 其实就是 RuntimeInit 的内部静态类，他是个Runnable 对象，run方法就是通过 invoke 传入的方法。

从上述一系列流程可以看到，终于到了 SystemServer#main 中

# SystemServer 干了什么

上文可以看到，SystemServer的入口就是他的 main 方法

```java
public static void main(String[] args) {
    new SystemServer().run();
}

    private void run() {
        try {
            ......
            // 准备主线程Looper（显然，现在就是主线程）
            android.os.Process.setThreadPriority(
                    android.os.Process.THREAD_PRIORITY_FOREGROUND);
            android.os.Process.setCanSelfBackground(false);
            Looper.prepareMainLooper();

            // 加载动态库 libandroid_servers.so
            System.loadLibrary("android_servers");
            performPendingShutdown();

            // 创建系统 context 对象
            createSystemContext();

            // 创建 SSM
            mSystemServiceManager = new SystemServiceManager(mSystemContext);
            mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);
            LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);
            SystemServerInitThreadPool.get();
        } finally {
            traceEnd();  // InitBeforeStartServices
        }

        // 启动 services
        try {
            traceBeginAndSlog("StartServices");
            // 启动引导服务
            startBootstrapServices();
            // 启动核心服务
            startCoreServices();
            // 启动其他服务
            startOtherServices();
            SystemServerInitThreadPool.shutdown();
        } catch (Throwable ex) {
            Slog.e("System", "******************************************");
            Slog.e("System", "************ Failure starting system services", ex);
            throw ex;
        } finally {
            traceEnd();
        }
        ......
    }
```

如上所以，SystemServer 首先创建了 SystemServerManager，然后在启动一些Services。

# 如何启动Service

上文中说道，启动service分为了三类，分别是

-  启动引导服务
- 启动核心服务
- 启动其他服务

以启动核心服务为例，代码如下：

```java
private void startCoreServices() {
    .......
    traceBeginAndSlog("StartBatteryService");
    // Tracks the battery level.  Requires LightService.
    mSystemServiceManager.startService(BatteryService.class);
    traceEnd();
	......
}
```

可以看到，启动一个服务，其实就是调用 SystemServerManager#startService 方法。

```java
/**
 * 通过className找到对应的Class
 */
public SystemService startService(String className) {
    final Class<SystemService> serviceClass;
    try {
        serviceClass = (Class<SystemService>)Class.forName(className);
    } catch (ClassNotFoundException ex) {
        .......
    }
    return startService(serviceClass);
}


/**
 * 通过反射，创建对应Service实例
 */
public <T extends SystemService> T startService(Class<T> serviceClass) {
    try {
        ......
        final T service;
        try {
            Constructor<T> constructor = serviceClass.getConstructor(Context.class);
            service = constructor.newInstance(mContext);
        }
        ......
        startService(service);
        return service;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
}

    /**
     * 调用service实例的 onStart 方法
     * @param service
     */
    public void startService(@NonNull final SystemService service) {
        // Register it.
        mServices.add(service);
        // Start it.
        long time = SystemClock.elapsedRealtime();
        try {
            service.onStart();
        } catch (RuntimeException ex) {
            throw new RuntimeException("Failed to start service " + service.getClass().getName()
                    + ": onStart threw an exception", ex);
        }
        warnIfTooLong(SystemClock.elapsedRealtime() - time, service, "onStart");
    }
```

可以看到，逻辑十分清晰，步骤如下

1. 通过 className 找到对应 Service 的 Class
2. 通过反射，创建 Service 实例
3. 把 Service 添加到 mServices 这个list中，然后调用 Service 实例的 onStart 方法

在 BatteryService 中，onStart 方法如下：

```java
@Override
public void onStart() {
    IBinder b = ServiceManager.getService("batteryproperties");
    final IBatteryPropertiesRegistrar batteryPropertiesRegistrar =
            IBatteryPropertiesRegistrar.Stub.asInterface(b);
    try {
        batteryPropertiesRegistrar.registerListener(new BatteryListener());
    } catch (RemoteException e) {
        // Should never happen.
    }

    mBinderService = new BinderService();
    publishBinderService("battery", mBinderService);
    publishLocalService(BatteryManagerInternal.class, new LocalService());
}
```

可以看到，首先会通过 ServiceManger#getService 获取到 binder 对象。

publishBinderService 内部最终会调用 ServiceManager#addService 方法，将当前的对象注册到 ServiceManager 中。

ServiceManager 是用来管理系统中各种 Service，用于 C/S 架构中的 Binder 通信。即 Clinet 需要使用到某个 Service，就会先到 ServiceManager 中找到这个 Service 的相关信息，然后根据这个 Service 的相关信息与 Service 所在的进程建立通信通路，这样 Client 就可以使用这个 Service了。

以上仅仅是 BatteryService 的启动过程，其他的 Service 类似，所有的 Service 都会注册到 ServiceManager 中，但是注册的方法是不一样的，不一定都是在 onStart 中。

# 总结

SystemService 进程被创建后，主要做了以下工作：

- 启动 Binder 线程池，这样就可以与其他进程进行通信
- 启动 SystemServiceManager，用于对系统的服务进行创建，启动以及生命周期管理
- 通过 SystemServiceManager 创建各种系统服务